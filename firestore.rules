rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * RETREAT APP SECURITY RULES (PROTOTYPING MODE)
     * 
     * Core Philosophy:
     * This ruleset enforces a strict user-ownership and multi-party collaborator model. 
     * It relies heavily on denormalization for authorization to ensure rules are fast 
     * and performant without requiring expensive get() calls.
     * 
     * Data Structure:
     * - User-private data is nested under /users/{userId}.
     * - Publicly discoverable profiles and listings (Hosts, Vendors, Spaces, Retreats) 
     *   exist at the top level with owner-only write permissions.
     * - Bookings and Transactions utilize a shared-access model where both the seeker 
     *   and the entity owner (host/vendor/spaceOwner) can view the data.
     * 
     * Key Security Decisions:
     * - Authorization Independence: Every document contains the UIDs required for 
     *   access decisions (e.g., hostId, seekerId, spaceOwnerId).
     * - Structural Segregation: User-specific private settings (SeekerProfile) 
     *   are nested under the user's root document to prevent accidental exposure.
     * - Prototyping Flexibility: Schema validation is limited to relational integrity 
     *   fields (IDs) to allow for rapid iteration on content fields.
     */

    // --- GLOBAL HELPER FUNCTIONS ---

    /** Checks if the request is from an authenticated user. */
    function isSignedIn() {
      return request.auth != null;
    }

    /** Checks if the authenticated user's UID matches the provided userId. */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /** Checks if the authenticated user owns the document and the document exists. */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /** Checks if the authenticated user's UID matches an ID field in the document data. */
    function isDataOwner(ownerId) {
      return isSignedIn() && request.auth.uid == ownerId;
    }

    /** Checks if the authenticated user's UID matches an ID field in the incoming request data. */
    function isIncomingDataOwner(ownerId) {
      return isSignedIn() && request.auth.uid == ownerId;
    }

    // --- COLLECTION RULES ---

    /**
     * @description Core user account data. Access is strictly limited to the account owner.
     * @path /users/{userId}
     * @allow (get, list, create, update) if auth.uid == userId
     * @deny Any access where auth.uid != userId
     * @principle Ownership: Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Private seeker profile details. Exclusively accessible by the owner.
       * @path /users/{userId}/seekerProfile/{seekerProfileId}
       * @allow (get, create) if auth.uid == userId
       * @deny Public reading or listing by other users.
       * @principle Ownership: Enforces document ownership for nested private data.
       */
      match /seekerProfile/{seekerProfileId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Publicly viewable Host profiles. Managed by the associated User.
     * @path /hosts/{hostId}
     * @allow (read) for all signed-in users. (write) if auth.uid matches document's userId.
     * @deny Updates to the userId field.
     * @principle Public Read with Owner-Only Writes.
     */
    match /hosts/{hostId} {
      allow get, list: if isSignedIn();
      allow create: if isIncomingDataOwner(request.resource.data.userId);
      allow update: if isDataOwner(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isDataOwner(resource.data.userId);
    }

    /**
     * @description Publicly viewable Vendor profiles. Managed by the associated User.
     * @path /vendors/{vendorId}
     * @allow (read) for all signed-in users. (write) if auth.uid matches document's userId.
     * @principle Public Read with Owner-Only Writes.
     */
    match /vendors/{vendorId} {
      allow get, list: if isSignedIn();
      allow create: if isIncomingDataOwner(request.resource.data.userId);
      allow update: if isDataOwner(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isDataOwner(resource.data.userId);
    }

    /**
     * @description Publicly viewable Space Owner profiles. Managed by the associated User.
     * @path /spaceOwners/{spaceOwnerId}
     * @allow (read) for all signed-in users. (write) if auth.uid matches document's userId.
     * @principle Public Read with Owner-Only Writes.
     */
    match /spaceOwners/{spaceOwnerId} {
      allow get, list: if isSignedIn();
      allow create: if isIncomingDataOwner(request.resource.data.userId);
      allow update: if isDataOwner(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isDataOwner(resource.data.userId);
    }

    /**
     * @description Publicly discoverable retreat listings.
     * @path /retreats/{retreatId}
     * @allow (read) for all signed-in users. (write) if auth.uid matches hostId.
     * @principle Relational Integrity: Ensures retreats are linked to the creator.
     */
    match /retreats/{retreatId} {
      allow get, list: if isSignedIn();
      allow create: if isIncomingDataOwner(request.resource.data.hostId);
      allow update: if isDataOwner(resource.data.hostId) && request.resource.data.hostId == resource.data.hostId;
      allow delete: if isDataOwner(resource.data.hostId);

      /**
       * @description Images for retreats. Self-authorizing via denormalized hostId.
       * @path /retreats/{retreatId}/images/{imageId}
       * @allow (write) if hostId in data matches auth.uid.
       */
      match /images/{imageId} {
        allow get, list: if isSignedIn();
        allow create: if isIncomingDataOwner(request.resource.data.hostId);
        allow update: if isDataOwner(resource.data.hostId) && request.resource.data.hostId == resource.data.hostId;
        allow delete: if isDataOwner(resource.data.hostId);
      }
    }

    /**
     * @description Publicly discoverable space listings.
     * @path /spaces/{spaceId}
     * @allow (read) for all signed-in users. (write) if auth.uid matches spaceOwnerId.
     * @principle Authorization Independence: Uses denormalized spaceOwnerId.
     */
    match /spaces/{spaceId} {
      allow get, list: if isSignedIn();
      allow create: if isIncomingDataOwner(request.resource.data.spaceOwnerId);
      allow update: if isDataOwner(resource.data.spaceOwnerId) && request.resource.data.spaceOwnerId == resource.data.spaceOwnerId;
      allow delete: if isDataOwner(resource.data.spaceOwnerId);

      /**
       * @description Images for spaces. Self-authorizing via denormalized spaceOwnerId.
       * @path /spaces/{spaceId}/images/{imageId}
       */
      match /images/{imageId} {
        allow get, list: if isSignedIn();
        allow create: if isIncomingDataOwner(request.resource.data.spaceOwnerId);
        allow update: if isDataOwner(resource.data.spaceOwnerId) && request.resource.data.spaceOwnerId == resource.data.spaceOwnerId;
        allow delete: if isDataOwner(resource.data.spaceOwnerId);
      }
    }

    /**
     * @description Bookings shared between a Seeker and an Entity Owner.
     * @path /bookings/{bookingId}
     * @allow (get, list) if auth.uid is seekerId OR bookedEntityOwnerId.
     * @allow (create) if auth.uid is seekerId.
     * @principle Shared Access: Grants visibility to both parties involved in a transaction.
     */
    match /bookings/{bookingId} {
      allow get, list: if isDataOwner(resource.data.seekerId) || isDataOwner(resource.data.bookedEntityOwnerId);
      allow create: if isIncomingDataOwner(request.resource.data.seekerId);
      allow update: if isDataOwner(resource.data.seekerId) && request.resource.data.seekerId == resource.data.seekerId;
      allow delete: if isDataOwner(resource.data.seekerId);

      /**
       * @description Financial transactions. Viewable by both parties, but read-only for users.
       * @path /bookings/{bookingId}/transactions/{transactionId}
       * @allow (write) if false; // System/Backend only.
       */
      match /transactions/{transactionId} {
        allow get, list: if isDataOwner(resource.data.seekerId) || isDataOwner(resource.data.bookedEntityOwnerId);
        allow create, update, delete: if false; 
      }
    }

    /**
     * @description User reviews for services and spaces.
     * @path /reviews/{reviewId}
     * @allow (read) for all signed-in users. (write) if auth.uid is reviewerId.
     * @principle Public Read with Owner-Only Writes.
     */
    match /reviews/{reviewId} {
      allow get, list: if isSignedIn();
      allow create: if isIncomingDataOwner(request.resource.data.reviewerId);
      allow update: if isDataOwner(resource.data.reviewerId) && request.resource.data.reviewerId == resource.data.reviewerId;
      allow delete: if isDataOwner(resource.data.reviewerId);
    }
  }
}